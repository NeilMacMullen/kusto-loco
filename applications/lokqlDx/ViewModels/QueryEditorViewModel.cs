using System.Text.Json;
using AvaloniaEdit.Document;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Intellisense;
using KustoLoco.Core.Settings;
using Lokql.Engine;
using lokqlDxComponents.Services;
using Microsoft.VisualStudio.Threading;
using NotNullStrings;

namespace LokqlDx.ViewModels;

public partial class QueryEditorViewModel : ObservableObject, IDisposable, IIntellisenseResourceManager,
    ICompletionManagerServiceLocator
{
    private readonly ConsoleViewModel _consoleViewModel;
    private readonly InteractiveTableExplorer _explorer;

    [ObservableProperty] private DisplayPreferencesViewModel _displayPreferences;
    [ObservableProperty] private TextDocument _document = new();
    [ObservableProperty] private QueryContextViewModel _queryContextViewModel = new();


    [ObservableProperty] private bool _textIsDirty;

    public QueryEditorViewModel(InteractiveTableExplorer explorer,
        ConsoleViewModel consoleViewModel, DisplayPreferencesViewModel displayPreferences,
        string initialText,
        string preQueryText,
        IntellisenseClientAdapter adapter
    )
    {
        _intellisenseClient = adapter;
        _explorer = explorer;
        _consoleViewModel = consoleViewModel;
        DisplayPreferences = displayPreferences;

        Document.Changing += Document_Changing;
        Document.Changed += Document_Changed;
        LoadIntellisense();
        //catch errors with plugin registration
        try
        {
            AddInternalCommands();
        }
        catch (Exception e)
        {
            SetText($"""
                     ERROR LOADING PLUGINS: 
                     {e.Message}
                     """);
            return;
        }

        SetText(initialText);
        QueryContextViewModel.Text = preQueryText;
        QueryContextViewModel.IsDirty = false;
        TextIsDirty = false;
        SetSchema(_explorer.GetSchema());
    }

    public SchemaIntellisenseProvider SchemaIntellisenseProvider { get; } = new();
    public int EditorOffset { get; set; }

    public IntellisenseClientAdapter _intellisenseClient { get; }


    public void Dispose()
    {
        Document.Changing -= Document_Changing;
        Document.Changed -= Document_Changed;
    }

    public IntellisenseEntry[] InternalCommands => _intellisenseClient.InternalCommands;
    public IntellisenseEntry[] KqlFunctionEntries { get; set; } = [];
    public IntellisenseEntry[] SettingNames { get; set; } = [];
    public IntellisenseEntry[] KqlOperatorEntries { get; set; } = [];

    public IntellisenseEntry[] GetTables(string blockText) => SchemaIntellisenseProvider.GetTables(blockText);
    public IntellisenseEntry[] GetColumns(string blockText) => SchemaIntellisenseProvider.GetColumns(blockText);

    public void AddSettingsForIntellisense(KustoSettingsProvider settings) =>
        SettingNames = settings.Enumerate()
            .Select(s => new IntellisenseEntry(s.Name, s.Value, string.Empty))
            .ToArray();

    public void SetSchema(SchemaLine[] getSchema) => SchemaIntellisenseProvider.SetSchema(getSchema);

    public event AsyncEventHandler? ExecutingQuery;

    private void Document_Changing(object? sender, DocumentChangeEventArgs e) => OnPropertyChanging(nameof(Document));

    private void Document_Changed(object? sender, DocumentChangeEventArgs e)
    {
        OnPropertyChanged(nameof(Document));
        TextIsDirty = true;
    }

    [RelayCommand(AllowConcurrentExecutions = false)]
    private async Task RunQuery(string query)
    {
        if (QueryContextViewModel.Text.IsNotBlank())
            query = QueryContextViewModel.Text + Environment.NewLine + query;
        await RunQueryString(query);
    }

    public async Task RunQueryString(string query)
    {
        if (query.IsBlank())
            return;
        await Messaging.Send(new RunningQueryMessage(true));
        if (ExecutingQuery is not null)
            await ExecutingQuery.InvokeAsync(this, EventArgs.Empty);

        ////start capturing console output from the engine
        _consoleViewModel.PrepareForOutput();
        ////run the supplied lines of kusto/commands
        ////Note that we need the extra Task.Run here to ensure
        ////that the UI thread is not blocked for reports generated by
        ////the engine
        await Task.Run(async () => await _explorer.RunInput(query));

        SetSchema(_explorer.GetSchema());
        AddSettingsForIntellisense(_explorer.Settings);
        AddInternalCommands(); //because we might have updated macros
        await Messaging.Send(new RunningQueryMessage(false));
    }


    private void LoadIntellisense()
    {
        using var functions = ResourceHelper.SafeGetResourceStream("IntellisenseFunctions.json");
        KqlFunctionEntries = JsonSerializer.Deserialize<IntellisenseEntry[]>(functions)!
            .Select(i => i with { Hint = IntellisenseHint.Function }).ToArray();
        using var ops = ResourceHelper.SafeGetResourceStream("IntellisenseOperators.json");
        KqlOperatorEntries = JsonSerializer.Deserialize<IntellisenseEntry[]>(ops)!
            .Select(i => i with { Hint = IntellisenseHint.Operator }).ToArray();
        AddSettingsForIntellisense(_explorer.Settings);
    }

    public void AddInternalCommands()
    {
        var verbEntries = _explorer._commandProcessor.GetVerbs(_explorer._loader);
        var macros = _explorer.ListMacros()
            .Select(m => new VerbEntry(m.Name, m.Description, false, []))
            .ToArray();
        var special = new[]
        {
            new VerbEntry("end", "ends a macro definition", false, [])
        };

        //add .end for macro definition
        var all = verbEntries
                .Concat(macros)
                .Concat(special)
                .ToArray();
        _intellisenseClient.SetInternalCommands(all);
    }

    public string GetText() => Document.Text;

    internal void SetText(string text) => Document.Text = text;


    public void Insert(string text)
    {
        var insertPoint = Math.Min(EditorOffset + 1, Document.TextLength);
        if (insertPoint < 0) insertPoint = 0;
        Document.Insert(insertPoint, text);
    }

    public bool IsDirty() => TextIsDirty || QueryContextViewModel.IsDirty;

    public void Clean()
    {
        TextIsDirty = false;
        QueryContextViewModel.IsDirty = false;
    }
}
