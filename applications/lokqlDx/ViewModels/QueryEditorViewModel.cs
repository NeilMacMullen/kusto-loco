using AvaloniaEdit.Document;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;
using Lokql.Engine;
using lokqlDxComponents.Contexts;
using lokqlDxComponents.Events;
using Microsoft.VisualStudio.Threading;
using NotNullStrings;

namespace LokqlDx.ViewModels;

public partial class QueryEditorViewModel : ObservableObject, IDisposable
{
    private readonly ConsoleViewModel _consoleViewModel;

    [ObservableProperty] private DisplayPreferencesViewModel _displayPreferences;
    [ObservableProperty] private TextDocument _document = new();
    private InteractiveTableExplorer _explorer;


    [ObservableProperty] private bool _isDirty;
    private readonly QueryEditorScopedContext _scopedContext;


    public QueryEditorViewModel(InteractiveTableExplorer explorer,
        ConsoleViewModel consoleViewModel, DisplayPreferencesViewModel displayPreferences,
        string initialText,
        QueryEditorScopedContext scopedContext
    )
    {
        _scopedContext = scopedContext;
        Messenger = _scopedContext.Messenger;
        _explorer = explorer;
        _consoleViewModel = consoleViewModel;
        DisplayPreferences = displayPreferences;

        Document.Changing += Document_Changing;
        Document.Changed += Document_Changed;
        SetText(initialText);
        _isDirty = false;
    }

    public IMessenger Messenger { get; }


    public void Dispose()
    {
        Document.Changing -= Document_Changing;
        Document.Changed -= Document_Changed;
        _scopedContext.Dispose();
    }


    public event AsyncEventHandler? ExecutingQuery;

    private void Document_Changing(object? sender, DocumentChangeEventArgs e) => OnPropertyChanging(nameof(Document));

    private void Document_Changed(object? sender, DocumentChangeEventArgs e)
    {
        OnPropertyChanged(nameof(Document));
        IsDirty = true;
    }

    [RelayCommand(AllowConcurrentExecutions = true)]
    private async Task RunQuery(string query)
    {
        if (query.IsBlank())
            return;
        var saved = await WeakReferenceMessenger.Default.Send(new RunningQueryMessage(true));
        if (ExecutingQuery is not null)
            await ExecutingQuery.InvokeAsync(this, EventArgs.Empty);

        ////start capturing console output from the engine
        _consoleViewModel.PrepareForOutput();
        ////run the supplied lines of kusto/commands
        ////Note that we need the extra Task.Run here to ensure
        ////that the UI thread is not blocked for reports generated by
        ////the engine
        await Task.Run(async () => await _explorer.RunInput(query));
        Messenger.Send<QueryExecutedMessage>();


        //WeakReferenceMessenger.Default.Send(new RunningQueryMessage(false));
    }




    public string GetText() => Document.Text;

    internal void SetText(string text) => Document.Text = text;
}
